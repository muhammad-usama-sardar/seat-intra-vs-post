{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2026-01-25T02:11:10.960825+00:00",
  "repo": "muhammad-usama-sardar/seat-intra-vs-post",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOQ5mD8c7jkUPU",
      "title": "Clarify scope: existing specs and real-world implementations",
      "url": "https://github.com/muhammad-usama-sardar/seat-intra-vs-post/issues/1",
      "state": "CLOSED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Clarify that the draft is based on existing specs and real-world implementations pointed in the given references. Any theoretical solutions are currently out of scope.",
      "createdAt": "2026-01-15T15:08:30Z",
      "updatedAt": "2026-01-17T13:50:55Z",
      "closedAt": "2026-01-17T13:50:55Z",
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "OWNER",
          "body": "and background check model",
          "createdAt": "2026-01-15T16:33:10Z",
          "updatedAt": "2026-01-15T16:33:10Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOQ5mD8c7jknwz",
      "title": "Emphasize simple Attester",
      "url": "https://github.com/muhammad-usama-sardar/seat-intra-vs-post/issues/2",
      "state": "CLOSED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "For simplicity and for WG to sync, no composite Attester etc. yet ",
      "createdAt": "2026-01-15T15:28:39Z",
      "updatedAt": "2026-01-17T13:51:05Z",
      "closedAt": "2026-01-17T13:51:05Z",
      "comments": []
    },
    {
      "number": 3,
      "id": "I_kwDOQ5mD8c7jk02W",
      "title": "Clarify Sec. 4.2.1",
      "url": "https://github.com/muhammad-usama-sardar/seat-intra-vs-post/issues/3",
      "state": "CLOSED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "> I do not understand Section 4.2.1\n\nExplain [Sec. 4.2.1](https://www.ietf.org/archive/id/draft-usama-seat-intra-vs-post-00.html#section-4.2.1) a little more.",
      "createdAt": "2026-01-15T15:41:41Z",
      "updatedAt": "2026-01-22T15:36:34Z",
      "closedAt": "2026-01-22T15:36:34Z",
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "OWNER",
          "body": "Find a suitable reference to cite here.",
          "createdAt": "2026-01-17T14:21:56Z",
          "updatedAt": "2026-01-17T14:21:56Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "OWNER",
          "body": "- https://mailarchive.ietf.org/arch/msg/rats/TFzusdvG5d0PSl5m0dY3nAeeUyQ/\n- https://datatracker.ietf.org/doc/draft-aylward-aiga-1/\n- https://datatracker.ietf.org/doc/draft-jiang-seat-dynamic-attestation/",
          "createdAt": "2026-01-22T10:31:28Z",
          "updatedAt": "2026-01-22T10:31:28Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOQ5mD8c7jlLGG",
      "title": "Session resumption is new connection",
      "url": "https://github.com/muhammad-usama-sardar/seat-intra-vs-post/issues/4",
      "state": "CLOSED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "> I don't agree with Section 4.2.3, as session resumption with fresh attestation could be used.\n\nDig archives for Ekr's email from charter time where he clarified that session resumption is a new \"connection\".",
      "createdAt": "2026-01-15T16:04:44Z",
      "updatedAt": "2026-01-17T13:51:17Z",
      "closedAt": "2026-01-17T13:51:17Z",
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "OWNER",
          "body": "https://mailarchive.ietf.org/arch/msg/seal/98THKBhYNlXPuNvrAv5N1f3afHU/",
          "createdAt": "2026-01-15T21:02:47Z",
          "updatedAt": "2026-01-15T21:02:47Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOQ5mD8c7j2dyR",
      "title": "Markus Rudy feedback",
      "url": "https://github.com/muhammad-usama-sardar/seat-intra-vs-post/issues/6",
      "state": "CLOSED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "[Archive link](https://mailarchive.ietf.org/arch/msg/seat/Pxr_12v6MIQIzGFTUdx04aVZYpM/)\n\n> Edgeless Systems has been using intra-handshake attested TLS in production since 2022, in at least two distinct confidential computing software products. From the [use-cases], we align mostly with *3.2. Secure Provisioning*: automatic dissemination of configuration and secrets between mutually attesting TEEs. I'd like to share my experience and perspective on the debate around intra-handshake and post-handshake attestation.\n> \n> The basics of [aTLS] are similar to [early-attestation] with only ephemeral keys, but since we needed (wanted) to work with existing TLS software, the messages are conveyed over different (potentially unrelated) extension points. We originally opted for an intra-handshake protocol to keep the attestation and verification parts out of the application logic, and to leave cryptographic heavy-lifting to the TLS stack. If we had known about [exporters] back then, we might have chosen a different approach.\n> \n> I identified the following issues with our current implementation, which are partially reflected in [intra-vs-post]:\n> \n> 1. \"Keeping attestation out of the application logic\" is not as straightforward as it sounds. In the background-check model, the attester needs to collect evidence in response to the relying party's challenge (nonce). We were lucky that the Golang TLS stack can be supplied with arbitrary closures that are called during the handshake, but in my experience this is a rare design choice and may also be difficult to implement in other languages.\n> \n> 2. Conveying the evidence is not enough, it needs to be verified as well in order to end up with a trustworthy channel. We decided to integrate verification into the handshake, too, but that has massive drawbacks: Verification can take orders of magnitude longer than normal TLS handshakes, and usually involves remote calls, affecting all sorts of timeouts. However, doing the verification at the application level would require forwarding information from the handshake (e.g. nonce), at which point the application needs to be fully aware of the handshake protocol in order to verify it, breaking the intended layering.\n> \n> 3. There's only so much information in a TLS alert message, and it's definitely not enough to understand remote verification failures. While I understand this to be a deliberate design choice by TLS, I found this to be a hindrance for operating and debugging a large number of services in practice.\n> \n> 4. I don't think saving extra roundtrips is an appropriate design goal when attestation is required. Generating evidence alone takes much longer than normal network roundtrip times, not even speaking of verification.\n> \n> All of the above leads me to a strong preference for a post-handshake protocol. In addition, I have justified hopes that a post-handshake protocol would also have the following benefits:\n> \n> A. It's much easier to adopt an attestation protocol if it does not require TLS libraries to add support first! Established libraries are slow to change and may even be reluctant to implement all published extensions.\n> B. It should be possible to port the general shape of a post-handshake attested TLS protocol to other protocols that provide secure channels and session binding (Noise comes to mind).\n> C. (Formal) verification of a protocol and audit of its implementations might be much easier if it ran *on top of* TLS. Existing proofs and certifications would not need to be reevaluated.\n> \n> Thanks for the consideration!\n> \n> Cheers, Markus\n> \n> [use-cases]: https://www.ietf.org/archive/id/draft-mihalcea-seat-use-cases-00.html\n> [intra-vs-post]: https://www.ietf.org/archive/id/draft-usama-seat-intra-vs-post-00.html\n> [aTLS]: https://github.com/edgelesssys/contrast/blob/3bd17f8/docs/docs/architecture/attestation/atls.md\n> [early-attestation]: https://www.ietf.org/archive/id/draft-fossati-seat-early-attestation-02.html\n> [exporters]: https://www.rfc-editor.org/rfc/rfc5705.html\n> [id-crisis]: https://github.com/CCC-Attestation/formal-spec-id-crisis\n\n",
      "createdAt": "2026-01-16T16:21:00Z",
      "updatedAt": "2026-01-17T13:51:26Z",
      "closedAt": "2026-01-17T13:51:26Z",
      "comments": []
    },
    {
      "number": 7,
      "id": "I_kwDOQ5mD8c7j6WS5",
      "title": "Ayoub Benaissa feedback",
      "url": "https://github.com/muhammad-usama-sardar/seat-intra-vs-post/issues/7",
      "state": "CLOSED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "[Archive link](https://mailarchive.ietf.org/arch/msg/seat/Bn9xDWrnv6NVWXr4IPaXCETL5EI/)\n\n>From a practical perspective, I think a post-handshake implementation makes\nmore sense. We have been building an Attested TLS protocol for a web-based\napplication, and we had to do a post-handshake implementation.\nIntra-handshake requires too much change. For example, you have to\nreimplement or customize how Nginx (or other) servers speak TLS. This would\ntake months and more to have a standard implementation that is somehow safe\nto use. It's different in a post-handshake implementation where you can\nhave a full working example in a matter of weeks.\n\n[Archive link2](https://mailarchive.ietf.org/arch/msg/seat/8eynK9ky5F-TcnL_UPbSRDKuK1E/)\n\n> For what I said about post-handshake vs intra-handshake, I will try to\n> elaborate with a few points:\n> - TLS might not be well suited to include this in its protocol. Not sure\n> TEEs are even as mature for the people to see that it should be included\n> right now. The plan to make it a post-handshake protocol makes more sense\n> right now. A future where it's incorporated into TLS might exist, but I\n> don't think there is enough motivation right now.\n> - An intra-handshake requires much more work compared to a post-handshake.\n> People need to agree on how to add this as optional in TLS (we can't force\n> everyone to use it of course), the standard needs to be implemented by\n> major libraries, and then it will be available in major client/server\n> applications. If any of the prior steps doesn't go through, it means you\n> have to patch your components to make it work, which is not convenient /\n> less secure.\n> - We already implemented a post-handshake protocol and have a full demo\n> working. We were able to do this in a matter of weeks. That's because you\n> don't need to modify any TLS implementation, but only add a few\n> verification steps after the usual TLS handshake. This is almost the same\n> on the client and server side.\n> \n> I also want to point out that the need for such a protocol is high. I can\n> talk about how LLMs are being served with TEEs, and everyone is doing the\n> attested TLS differently. A standard leading to a major and secure\n> implementation that can be used in browsers and so on would really benefit\n> the people.",
      "createdAt": "2026-01-16T21:30:03Z",
      "updatedAt": "2026-01-17T13:51:42Z",
      "closedAt": "2026-01-17T13:51:42Z",
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "OWNER",
          "body": "Follow-up: \n* web-based application\n* LLMs\n* browsers",
          "createdAt": "2026-01-16T21:53:51Z",
          "updatedAt": "2026-01-16T21:53:51Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOQ5mD8c7kAVsP",
      "title": "Use cases?",
      "url": "https://github.com/muhammad-usama-sardar/seat-intra-vs-post/issues/8",
      "state": "OPEN",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Discuss whether to add use cases in it",
      "createdAt": "2026-01-17T14:30:22Z",
      "updatedAt": "2026-01-19T15:12:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "OWNER",
          "body": "See #11 ",
          "createdAt": "2026-01-19T15:12:37Z",
          "updatedAt": "2026-01-19T15:12:37Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOQ5mD8c7kSJQp",
      "title": "Mike Bursell feedback on -01",
      "url": "https://github.com/muhammad-usama-sardar/seat-intra-vs-post/issues/10",
      "state": "CLOSED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "[Archive link](https://lists.confidentialcomputing.io/g/attestation/message/276)\n\n> Usama -\n> \n> This reads well to me, and I think that the additional feedback from\n> Ayoub and Markus adds further context and credibility.\n> \n> My only feedback is minor, and would be around Section 6:\n> \"Intra-handshake attestation only adds unnecessary complexity which is\n> avoidable. All use cases of intra-handshake attestation can be covered\n> by post-handshake attestation (by doing attestation round immediately\n> after Connection Establishment Time) but not the other way around.\"\n> \n> I'm wary of unqualified use of words like \"all\" in this context. \n> Unless you're certain that all use possible use cases have been\n> considered (and you may be, but that wasn't clear to me from my reading\n> of this doc), then I'd suggest something like \"All known use cases...\"\n> or \"All identified use cases...\".\n> \n> -Mike.",
      "createdAt": "2026-01-19T14:24:12Z",
      "updatedAt": "2026-01-19T14:44:12Z",
      "closedAt": "2026-01-19T14:44:12Z",
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "OWNER",
          "body": "Addressed [here](https://github.com/muhammad-usama-sardar/seat-intra-vs-post/commit/94ea510372f35f8257689d267a070856f9386bb4)",
          "createdAt": "2026-01-19T14:44:12Z",
          "updatedAt": "2026-01-19T14:44:12Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOQ5mD8c7kS1Bk",
      "title": "Edgeless Systems use case and experiment results",
      "url": "https://github.com/muhammad-usama-sardar/seat-intra-vs-post/issues/11",
      "state": "CLOSED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "[Archive link](https://mailarchive.ietf.org/arch/msg/seat/iAeCQLna8FdfoQGV3P-mEHUobn4/)\n\n> Hi Usama,\n> \n> Contrast is the main product that should be named. Constellation was using the same protocol, but the project is archived since 2026. Funnily enough, I just learned that our earlier SGX-based products did post-handshake attestation.\n> \n> I don't know whether our patterns justify a new use case, but since you asked: A Contrast system has three types of participants - User, Coordinator, Workload. The latter two types run in TEEs, with the following communication flows (numbered for reference, not for temporal ordering):\n> \n> 1. The user creates an aTLS channel to the Coordinator, and if it passes all checks the user configures it with root key material. The Coordinator creates an internal CA for workloads. Only the Coordinator attests. This happens infrequently.\n> 2. Workloads create aTLS channels to the Coordinator and send a CSR. If the Coordinator is satisfied with the workload's attestation, it signs a certificate for the workload. Together with the CA certificate, workloads can now communicate with standard mTLS using these certificates (no more attestation involved). This happens frequently (with Kubernetes pod starts/restarts). While the CSR could be signed without an attested TLS channel, it's easier for the workload to trust the response this way. Furthermore, some workloads also obtain a persistent secret seed over this channel, which they can use to derive durable key material themselves (e.g. volume decryption key).\n> 3. Coordinators contact other Coordinators to obtain the root key material for themselves. Both sides need to attest to ensure trustworthiness. This happens infrequently.\n> \n> I did a quick experiment in our testing lab, running on the same machine as the Coordinator:\n> \n> 1. TCP connections are local, and thus the TCP connection establishment unsurprisingly takes only 0.5ms. But even to neighbouring nodes in the same cluster, the TCP handshake takes below 2ms.\n> 2. I measured generation of evidence including the TLS session establishment, but with these numbers I don't think it makes a lot of difference:\n>    - SNP: Median time of 140ms from TCP SYN to TLS channel established and evidence sent to the client.\n>    - TDX: Median time of 1020ms, same procedure. I don't know why it is that slow, it should only be making machine-local remote calls, if any.\n> 3. So far, I only managed to measure TDX verification, which adds another 340ms. This is bound by remote HTTP requests, afaiu, and could be optimized with locally cached collateral, CRL, etc. I'd expect SNP to exhibit similar timing, because verification does similar remote calls.\n> \n> Cheers, Markus",
      "createdAt": "2026-01-19T15:10:42Z",
      "updatedAt": "2026-01-19T23:11:57Z",
      "closedAt": "2026-01-19T23:11:57Z",
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "OWNER",
          "body": "Addressed [here](https://github.com/muhammad-usama-sardar/seat-intra-vs-post/commit/d147346fb2e7aa2e58dc5537813a0ed2ad307aa2)",
          "createdAt": "2026-01-19T23:11:57Z",
          "updatedAt": "2026-01-19T23:11:57Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOQ5mD8c7kgPvE",
      "title": "Carey Wilson review of -02",
      "url": "https://github.com/muhammad-usama-sardar/seat-intra-vs-post/issues/15",
      "state": "OPEN",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "[CCC TAC archive link](https://lists.confidentialcomputing.io/g/tac/message/1711)\n\n> thank you for putting together this taxonomy and analysis - it gets very quickly to the heart of the tradeoffs in the ATLS space, and I\u2019ve already found it immensely informative.\n> \n> I wanted to raise a point that is discussed in the draft, but that I think may be worth sharpening further. It seems unavoidable that many, near-term uses of attestation will rely on non-ephemeral server-side state that must remain confidential, and that cannot feasibly be handled client-side only.\n> \n> Confidential AI is an emerging workload class for confidential computing, with requirements that explicitly include durable and confidential state governance. It inherently depends on (1) hardware capable of running large models, which has no short-term path to being feasible on consumer devices, and (2) mechanisms to query, synchronize, and protect large volumes of contextual data, which are similarly impractical to manage entirely on the client.\n> \n> This line of thinking appears consistent with the draft\u2019s motivation for post-handshake attestation, as well as the observation that intra-handshake attestation cannot account for state changes over the lifetime of a system. What I am curious about is whether it would be useful to frame this more explicitly as a general systems constraint: namely, that once durable, confidential server-side state is involved, trust decisions and key management inevitably live above the transport layer, with TLS (and ATLS) primarily providing binding and freshness rather than being the locus of trust itself.\n> \n> I\u2019m wondering whether this framing would be helpful as future work, particularly when thinking about the relative prioritization of ATLS mechanisms versus application-level attestation solutions for stateful services.\n\nNeed to clarify terms: \n\n- non-ephemeral server-side state\n- durable, confidential server-side state\n- stateful services\n- durable and confidential state governance\n",
      "createdAt": "2026-01-20T13:05:12Z",
      "updatedAt": "2026-01-20T16:01:20Z",
      "closedAt": null,
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "OWNER",
          "body": "[CCC TAC Archive link](https://lists.confidentialcomputing.io/g/tac/message/1714)\n\n> Thanks for your response. For each of these, when I say \"state\" I am referring specifically to the application-level data that must remain confidential to run a \"confidential ai\" service, the three primary classes being:\n> \n> 1. Contextual data used at inference time. This could be prompts, retrieved documents, conversation history, tool state, etc. This data is large and evolves over time.\n> 2. Customer managed cryptographic material for encryption and identity. These are long-lived and user recoverable and should only ever be accessible in the client or in the tee. Possibly this could be service-managed as well.\n> 3. Trained model weights or parameters\n> \n> Though I was primarily thinking of 1) and 2) for the majority of confidential ai use cases.\n> \n> By \"non-ephemeral\" or \"durable\" server side state, I mean state that persists across TLS connections and sessions, evolves over time, and cannot be practically managed solely on the client. Outside of confidential AI, one could argue most cases could be handled via more classic end to end encryption, where data is only ever plaintext on the client. In such cases, ATLS can add useful guarantees about binding server behavior to an attested execution environment.\n> \n> In contrast, for confidential AI, the classes of data in (1) and (3) are often not feasible to exist only on the client. As a result, they are pushed to server-side execution environments that are capable of both running data- and compute-intensive workloads and producing attestation evidence. My intended point was that, for such provider-specific confidential AI services, the platform operator will likely need to present application-level attestation to users, so that claims about how these classes of data are handled can be evaluated and enforced.\n> \n> As an example, a browser-side SDK or client is effectively constrained to application-layer attestation. In a web-based interaction model, which is likely a primary way many users will interact with confidential AI, client-side decisions (e.g., whether it is safe to send sensitive data to the service) must generally be made at the application level, since the TLS stack is not extensible or observable from browser code.",
          "createdAt": "2026-01-20T16:01:20Z",
          "updatedAt": "2026-01-20T16:01:20Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "I_kwDOQ5mD8c7k_hJu",
      "title": "Meiling Chen's review of -02",
      "url": "https://github.com/muhammad-usama-sardar/seat-intra-vs-post/issues/16",
      "state": "OPEN",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "[Archive link](https://mailarchive.ietf.org/arch/msg/seat/aW8EYY1Dc3oCRWUYaUll2omkxdc/)\n\n> Hi all,\n> I have reviewed the draft, it seems like Intra-handshake and Post-handshake Attestation Are Complementary. \n> \n> - Intra-handshake attestation is ideal for initial high-assurance authentication (e.g., financial transactions, secure government access), where attestation must be completed before the connection is fully established.\n> - Post-handshake attestation better supports long-lived connections and dynamic attestation, offering flexibility without modifying TLS.\n> \n> No scheme is absolutely perfect, my previous attention had been focused on the post-handshake attestation, When considering the limitations on post-handshake, the following points are also recommended to be taken into consideration\n> \n> - State synchronization challenges, in long connections, if the proving party undergoes a state change (such as being compromised) after the handshake, the relying party needs to promptly detect this and terminate the connection. This may require an additional state synchronization mechanism.\n> - Unclear interaction with TLS session resumption: If the TLS session recovery mechanism is enabled, it is necessary to clarify how to coordinate after the handshake to ensure that the recovered session still support post-handshake attestation.\n> \n> So actually, I didn't quite understand where the core contradiction lay. If both of these two methods are to be continued, maybe  clarify the boundaries, explore hybrid approaches, or solve the problem of evidence replication in the intra-handshake attestation.\n\n",
      "createdAt": "2026-01-22T08:38:47Z",
      "updatedAt": "2026-01-22T08:38:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "OWNER",
          "body": "[My response](https://mailarchive.ietf.org/arch/msg/seat/2jokQYPBWdNMhrwBxEYuhb9r-ro/)",
          "createdAt": "2026-01-22T08:38:51Z",
          "updatedAt": "2026-01-22T08:38:51Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOQ5mD8c7k_qfS",
      "title": "Yaroslav review of -02",
      "url": "https://github.com/muhammad-usama-sardar/seat-intra-vs-post/issues/17",
      "state": "CLOSED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "[Archive link](https://mailarchive.ietf.org/arch/msg/seat/gQTdMo0OexLffcB1x39M4J57Ug4/)\n\n> Here is my review as an individual contributor (not wearing any hats).\n> \n> Overall, I find the discussion useful and the concrete implementation feedback (such as latency measurements) very valuable. I do think a few conclusions are currently stated more strongly than the text supports.\n> \n> \n\n- [x] Section 3 (Pre-handshake attestation):\n\n> \n> The current dismissal seems to assume Evidence can be arbitrarily old relative to connection establishment. Many signed artifacts carry issuance time and validity constraints (e.g., JWT iat/exp [0], HTTP Message Signatures created/expires [1], SAML conditions [2]). A timestamp alone is not the same as freshness, but a short validity window plus a trustworthy time source can be an acceptable assurance mechanism in some deployments. Likewise, some schemes can provide stronger freshness via verifier-chosen challenges or monotonic counters. I suggest separating \"not contemporaneous with this TLS connection\" from \"too old to be meaningful\", and discussing under what threat models / deployment assumptions pre-handshake is insufficient.\n> Section 3 does not currently mention potential benefits of pre-handshake (e.g., no modification of TLS, no changes to application protocols, potential caching/scalability advantages). Even if you ultimately judge these insufficient, listing them would make the draft more balanced.\n> \n> \n\n- [x] Section 4 (Intra-handshake attestation):\n\n> \n> I don't think \"embedding evidence in the handshake\" automatically guarantees freshness. Freshness typically depends on an unpredictable, single-use challenge and clear replay handling. If Evidence (or the challenge it is bound to) can be reused, the freshness property doesn't follow merely from being carried in handshake messages.\n> More generally, the text would benefit from explicitly stating what is being bound to what (e.g., transcript hash, exporter, traffic secrets, application traffic secrets) and which concrete mechanisms provide that binding.\n> \n> \n\n- [x] Section 4.1.2 / 4.2.4 (Round trips and latency):\n\n> \n> The argument that avoiding an extra RTT is not a relevant goal may depend heavily on deployment topology (LAN vs same-region vs cross-continent). The data point you include is still helpful.\n> Section 4.2.4 (high handshake latency) seems closely related to 4.1.2; you might consider merging them and broadening the analysis to include \"baseline handshake costs\" (including how PQ transition may change the baseline).\n> \n\n- [x] Section 4.2.1 (Limited claims availability):\n\n> \n> I'm not convinced the limitation is specific to intra-handshake without a clearer definition. What exactly is meant by \"limited claims\"? Which claims are unavailable intra-handshake but available pre- or post-handshake, and why? Concrete examples (even a short list) would help.\n> \n\n- [x]  Section 4.2.2 (Invasive changes in TLS):\n\n> \n> It's not clear to me that intra-handshake attestation inherently requires modifications to the TLS key schedule. Could a design based on standard TLS extensions and explicit transcript/channel binding (via early exporters) satisfy the required security properties? If not, it would be useful to explain in the draft text which properties force more invasive changes.\n> \n\n- [x]  Section 5.1.4 (Latency placement):\n\n> \n> I don't think that moving latency related to attestation into after handshake is always a good thing. In some real-time and streaming applications, a spike after the session is established may be much more disruptive than paying a cost during the handshake. It would help to discuss this as a trade-off.\n> \n\n- [x] Section 5.1.6 (Ease of implementation):\n\n> \n> A working demo is great, but I'm not sure it translates directly into \"ease of implementation\" for production deployments. Production-oriented examples (especially showing Exported Authenticators usage) would make this argument much more compelling.\n> \n\n- [x] Section 5.2.1 (Impact on application layer):\n> \n> This is my biggest concern with the post-handshake approach as currently written. Exported Authenticators define a secure way to serialise and bind authenticators, but each application protocol still needs a way to negotiate, carry, and process those structures. So far, this has not been easy even for HTTP (HTTP working group is still focused only on unsolicited server-side authenticators [3]). I suggest expanding this section into a more concrete discussion of deployment paths, and what is realistically required in applications and/or infrastructure.\n> \n> \n> \n\n- [x] General\n\n> The analysis appears to skip a potentially important design point: an explicit shim or gating layer that performs attestation after the TLS handshake completes but before any application data is exchanged. This is operationally distinct from both intra-handshake attestation and fully application-integrated post-handshake attestation. Such an approach could preserve standard TLS handshake behaviour and latency characteristics, avoid invasive TLS changes, and still prevent application data from flowing until attestation succeeds. It may also mitigate some of the application-layer complexity by localizing attestation handling to a well-defined enforcement point (e.g., a sidecar or connection gate) rather than requiring per-protocol integration.\n> \n> Is there a specific reason this design point was excluded? If not, it may be worth explicitly analysing it as a distinct option, or clarifying whether and why it is considered equivalent to \"post-handshake\" in the current text.\n> \n> \n> Hope this helps.\n\n[0] https://www.rfc-editor.org/rfc/rfc7519.html#section-4.1.6\n[1] https://www.rfc-editor.org/rfc/rfc9421.html#signature-params\n[2] https://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf\n[3] https://datatracker.ietf.org/doc/draft-ietf-httpbis-secondary-server-certs",
      "createdAt": "2026-01-22T08:49:35Z",
      "updatedAt": "2026-01-22T16:12:29Z",
      "closedAt": "2026-01-22T15:36:27Z",
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "OWNER",
          "body": "> Section 3 (Pre-handshake attestation):\n\nmainly because nobody has yet submitted a draft on it. In the mean time, add a reference to [security considerations section](https://www.ietf.org/archive/id/draft-usama-seat-intra-vs-post-02.html#section-8). If someone submits a draft, I can expand this discussion.\n\n> Section 4 (Intra-handshake attestation):\n\nAdd a reference to [binding analysis](https://mailarchive.ietf.org/arch/msg/seat/x3eQxFjQFJLceae6l4_NgXnmsDY/)\n\n> Section 4.1.2 / 4.2.4 (Round trips and latency):\n\nAgree. Possibly request Markus for analysis of: \n- within continent\n- cross-continent\n\n> Section 4.2.1 (Limited claims availability):\n\nDynamic TCB (dynamic TE): add examples of agentic AI\n\n> Section 4.2.2 (Invasive changes in TLS):\n\nAdd a reference to [binding analysis](https://mailarchive.ietf.org/arch/msg/seat/x3eQxFjQFJLceae6l4_NgXnmsDY/), which includes early exporters\n\n> Section 5.1.4 (Latency placement):\n\nLayer in between the actual application \n\n`TLS (any implmentation) -> aTLS library -> Application Layer`\n\n> Section 5.1.6 (Ease of implementation):\n\nAdd Google's and SCONE's examples [mentioned later](https://www.ietf.org/archive/id/draft-usama-seat-intra-vs-post-02.html#section-7.2) in this section\n\n> Section 5.2.1 (Impact on application layer):\n\n\"Shim layer\" is still post-handshake as per [definition](https://www.ietf.org/archive/id/draft-usama-seat-intra-vs-post-02.html#section-1). Discussions are happening in CCC in favor of this option.",
          "createdAt": "2026-01-22T08:59:04Z",
          "updatedAt": "2026-01-22T09:39:36Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "OWNER",
          "body": "[Short response](https://mailarchive.ietf.org/arch/msg/seat/snwwZWiyGOVk_QXTKeUpodkv9Lo/)",
          "createdAt": "2026-01-22T16:12:29Z",
          "updatedAt": "2026-01-22T16:12:29Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 5,
      "id": "PR_kwDOQ5mD8c69bmBf",
      "title": "Address feedback from Paul, Ayoub and Markus",
      "url": "https://github.com/muhammad-usama-sardar/seat-intra-vs-post/pull/5",
      "state": "MERGED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "- clarify scope\r\n- addresses #1, #2, #4, #6, and #7",
      "createdAt": "2026-01-15T17:21:48Z",
      "updatedAt": "2026-01-17T13:50:33Z",
      "baseRepository": "muhammad-usama-sardar/seat-intra-vs-post",
      "baseRefName": "main",
      "baseRefOid": "59a5bcdd8c044997822185211f636991c0b32917",
      "headRepository": "muhammad-usama-sardar/seat-intra-vs-post",
      "headRefName": "feedback",
      "headRefOid": "5014624b70fc31b978a846a24dc90132524c1161",
      "closedAt": "2026-01-17T13:50:33Z",
      "mergedAt": "2026-01-17T13:50:32Z",
      "mergedBy": "muhammad-usama-sardar",
      "mergeCommit": {
        "oid": "648136489b2e93f94a318e364bfe83fbc20ad1d6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 9,
      "id": "PR_kwDOQ5mD8c69zmv7",
      "title": "Fix typos",
      "url": "https://github.com/muhammad-usama-sardar/seat-intra-vs-post/pull/9",
      "state": "MERGED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2026-01-17T19:10:01Z",
      "updatedAt": "2026-01-17T19:11:37Z",
      "baseRepository": "muhammad-usama-sardar/seat-intra-vs-post",
      "baseRefName": "main",
      "baseRefOid": "648136489b2e93f94a318e364bfe83fbc20ad1d6",
      "headRepository": "muhammad-usama-sardar/seat-intra-vs-post",
      "headRefName": "feedback02",
      "headRefOid": "817cf4d0c27befb773d9c93ba021be715ecb9acb",
      "closedAt": "2026-01-17T19:11:37Z",
      "mergedAt": "2026-01-17T19:11:37Z",
      "mergedBy": "muhammad-usama-sardar",
      "mergeCommit": {
        "oid": "ec546edbc4890acf086c558a44ed262d3e6c41ac"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOQ5mD8c6-CKN-",
      "title": "Mike Bursell feedback",
      "url": "https://github.com/muhammad-usama-sardar/seat-intra-vs-post/pull/12",
      "state": "MERGED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "https://lists.confidentialcomputing.io/g/attestation/message/276",
      "createdAt": "2026-01-19T15:29:50Z",
      "updatedAt": "2026-01-19T15:30:04Z",
      "baseRepository": "muhammad-usama-sardar/seat-intra-vs-post",
      "baseRefName": "main",
      "baseRefOid": "ec546edbc4890acf086c558a44ed262d3e6c41ac",
      "headRepository": "muhammad-usama-sardar/seat-intra-vs-post",
      "headRefName": "feedback02",
      "headRefOid": "94ea510372f35f8257689d267a070856f9386bb4",
      "closedAt": "2026-01-19T15:30:04Z",
      "mergedAt": "2026-01-19T15:30:04Z",
      "mergedBy": "muhammad-usama-sardar",
      "mergeCommit": {
        "oid": "c9bdf939bc2dd3e09b4f9a8bd171a07f4feb2084"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 13,
      "id": "PR_kwDOQ5mD8c6-GLzp",
      "title": "Markus experiment",
      "url": "https://github.com/muhammad-usama-sardar/seat-intra-vs-post/pull/13",
      "state": "MERGED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Based on https://mailarchive.ietf.org/arch/msg/seat/iAeCQLna8FdfoQGV3P-mEHUobn4/",
      "createdAt": "2026-01-19T22:48:01Z",
      "updatedAt": "2026-01-19T22:48:15Z",
      "baseRepository": "muhammad-usama-sardar/seat-intra-vs-post",
      "baseRefName": "main",
      "baseRefOid": "c9bdf939bc2dd3e09b4f9a8bd171a07f4feb2084",
      "headRepository": "muhammad-usama-sardar/seat-intra-vs-post",
      "headRefName": "feedback02",
      "headRefOid": "d147346fb2e7aa2e58dc5537813a0ed2ad307aa2",
      "closedAt": "2026-01-19T22:48:15Z",
      "mergedAt": "2026-01-19T22:48:15Z",
      "mergedBy": "muhammad-usama-sardar",
      "mergeCommit": {
        "oid": "cfb987fd21717a21451ea35eb44e2a3957d970a8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 14,
      "id": "PR_kwDOQ5mD8c6-KuS7",
      "title": "Charter text + Markus quote",
      "url": "https://github.com/muhammad-usama-sardar/seat-intra-vs-post/pull/14",
      "state": "MERGED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2026-01-20T09:23:20Z",
      "updatedAt": "2026-01-20T09:23:28Z",
      "baseRepository": "muhammad-usama-sardar/seat-intra-vs-post",
      "baseRefName": "main",
      "baseRefOid": "cfb987fd21717a21451ea35eb44e2a3957d970a8",
      "headRepository": "muhammad-usama-sardar/seat-intra-vs-post",
      "headRefName": "feedback02",
      "headRefOid": "3e42efb0ebc57b00e92fa2422b7cddff9112e1bf",
      "closedAt": "2026-01-20T09:23:28Z",
      "mergedAt": "2026-01-20T09:23:28Z",
      "mergedBy": "muhammad-usama-sardar",
      "mergeCommit": {
        "oid": "06ee066640f9ed3ed89aa40cb65a6b18e63b4c30"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 18,
      "id": "PR_kwDOQ5mD8c6-vN6v",
      "title": "#3 and #17",
      "url": "https://github.com/muhammad-usama-sardar/seat-intra-vs-post/pull/18",
      "state": "MERGED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "#3  \r\n#17  ",
      "createdAt": "2026-01-22T16:30:54Z",
      "updatedAt": "2026-01-22T16:31:14Z",
      "baseRepository": "muhammad-usama-sardar/seat-intra-vs-post",
      "baseRefName": "main",
      "baseRefOid": "06ee066640f9ed3ed89aa40cb65a6b18e63b4c30",
      "headRepository": "muhammad-usama-sardar/seat-intra-vs-post",
      "headRefName": "feedback03",
      "headRefOid": "2b85809790937b88e812ae2fd9c2bbd35c9ea604",
      "closedAt": "2026-01-22T16:31:13Z",
      "mergedAt": "2026-01-22T16:31:13Z",
      "mergedBy": "muhammad-usama-sardar",
      "mergeCommit": {
        "oid": "5afa56bf4b0f752569bb5db13fffcc2fc60d5f15"
      },
      "comments": [],
      "reviews": []
    }
  ]
}